# 数据库技术
## 通用
### SQL技巧
最左前缀原则 多列索引在where的顺序必须和定义一直，不然用不到索引(因为B+书保持索引顺序是按照定义的顺序)
虽然是顺序但是第一个范围有< > <= <=等不行， like对于abcd%可用所以，但是%abcd%不行
索引类参与计算则不能起作用，如where a + 1 = 1000, convert(col,char(3))等

or/in会遍历表就算有索引,UNION All 直接返回并集，可以避免去重的开销
1. 避免使用NULL字段
2. 很难进行查询优化
3. NULL列加索引，需要额外空间
4. 含NULL复合索引无效

union删除重复行，union all保留重复行，intersect取公共行，except从第一个结果集中删除第二个结果集的数据

||级联字符串，如果一个为null则为null

字符字段必须建前缀索引

一条SQL叧能在一个CPU运算, 简单SQL缓存命中率更高，可多条并行，拒绝大SQL

避免负向查询如not != not in等
避免count(*)/count(1)等， 使用count(col)

子查询改为JOIN, 例如

  原查询 SELECT a FROM T WHERE b = (SELECT SUM(b) FROM S WHERE T.a = S.a);
  改以后	SELECT T.a a FROM T JOIN S ON T.a = S.a GROUP BY T.key, T.a, T.b HAVING T.b = SUM(S.b);
  
### 理论
原子性和一致性：
区分这俩概念的关键，其实在一个"看"字，一致性约束的是一个用户写入并提交数据之后，其他用户去去读这条记录的时候，要么看到的是李雷还没有给韩梅梅转账的那个状态，要么就是李雷已经成功转账给了韩梅梅的状态，而在这两个状态之间的事务状态，比如李雷减少了100元，但韩梅梅还没加上这一百块的这个中间状态则不能够被其他人看到。而原子性只需要保证操作要么”最终“全部成功，要么”最终“全部失败而已。原子性不约束可见性，只保证操作的逻辑性。
这，就是一致性和原子性保证的差别。

B+-树是维护排序后的数据进行高效的插入、删除和搜索记录的树
B-树，节点为数组的树,比较适合磁盘操作

分布式事务：2阶段提交
两阶段提交的过程涉及到协调者和参与者。协调者可以看做成事务的发起者，同时也是事务的一个参与者。对于一个分布式事务来说，一个事务是涉及到多个参与者的。具体的两阶段提交的过程如下：

第一阶段：

首先，协调者在自身节点的日志中写入一条的日志记录，然后所有参与者发送消息prepare T，询问这些参与者（包括自身），是否能够提交这个事务；

参与者在接受到这个prepare T 消息以后，会根据自身的情况，进行事务的预处理，如果参与者能够提交该事务，则会将日志写入磁盘，并返回给协调者一个ready T信息，同时自身进入预提交状态状态；如果不能提交该事务，则记录日志，并返回一个not commit T信息给协调者，同时撤销在自身上所做的数据库改；

参与者能够推迟发送响应的时间，但最终还是需要发送的。

第二阶段：

协调者会收集所有参与者的意见，如果收到参与者发来的not commit T信息，则标识着该事务不能提交，协调者会将Abort T 记录到日志中，并向所有参与者发送一个Abort T 信息，让所有参与者撤销在自身上所有的预操作；

如果协调者收到所有参与者发来prepare T信息，那么协调者会将Commit T日志写入磁盘，并向所有参与者发送一个Commit T信息，提交该事务。若协调者迟迟未收到某个参与者发来的信息，则认为该参与者发送了一个VOTE_ABORT信息，从而取消该事务的执行。

参与者接收到协调者发来的Abort T信息以后，参与者会终止提交，并将Abort T 记录到日志中；如果参与者收到的是Commit T信息，则会将事务进行提交，并写入记录

一般情况下，两阶段提交机制都能较好的运行，当在事务进行过程中，有参与者宕机时，他重启以后，可以通过询问其他参与者或者协调者，从而知道这个事务到底提交了没有。当然，这一切的前提都是各个参与者在进行每一步操作时，都会事先写入日志。

唯一一个两阶段提交不能解决的困境是：当协调者在发出commit T消息后宕机了，而唯一收到这条命令的一个参与者也宕机了，这个时候这个事务就处于一个未知的状态，没有人知道这个事务到底是提交了还是未提交，从而需要数据库管理员的介入，防止数据库进入一个不一致的状态。当然，如果有一个前提是：所有节点或者网络的异常最终都会恢复，那么这个问题就不存在了，协调者和参与者最终会重启，其他节点也最终也会收到commit T的信息。

数据仓库：
数据仓库是企业级别的，数据集市是部门级别的
MOLAP: 多维数据存储，如CUBE等，数据load效率低
ROLAP:关系型数据存储，表存储，星型模型，事实表，维度表

### NoSQL: 
  1. Key-Value型，通过Key查询，不能通过Value查询，不能支持关系，不能回滚
  2. 文档型，其实是高级的K/V型，支持有嵌套的值，里面存XML,JSON等，比较适合日志啥的
  3. 列族型，相关数据存在一个列族里，最接近row/col概念，但不是定死的，比较弹性

## 乐观锁和悲观锁 
  1.悲观锁将记录锁住，防止别人读，会阻塞很多连接 
  2.乐观锁读取的时候记录一个版本号，在关系回去的时候会比较版本号，如果小于数据库的当前版本则提交失败 
  在Redis里用watch一个key来实现
